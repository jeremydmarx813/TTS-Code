# Week 3 Lecture - TTSJSAD

Learning goals for this week => Get more comfortable with the DOM and start thinking asynchronously.

## Agenda

    1) Week 4 Recap & Questions
    2) Week 5 Intro - Events, AJAX, Promises, Fetch
    3) Event Object
    4) Event Listeners
    5) Event Bubbling
    4) Async*
    5) AJAX*
    6) Promises*
    7) Fetch*
    8) JS App Setup **
    9) Webpack **

### 1. Week 4 Recap

- DOM Manipulation

### 3. Event Object

The Event interface represents an event which takes place in the DOM.

An event can be triggered by the user action e.g. clicking the mouse button or tapping keyboard, or generated by APIs to represent the progress of an asynchronous task. It can also be triggered programmatically, such as by calling the HTMLElement.click() method of an element, or by defining the event, then sending it to a specified target using EventTarget.dispatchEvent().

There are many types of events, some of which use other interfaces based on the main Event interface. Event itself contains the properties and methods which are common to all events.

Many DOM elements can be set up to accept (or "listen" for) these events, and execute code in response to process (or "handle") them. Event-handlers are usually connected (or "attached") to various HTML elements using EventTarget.addEventListener(), and this generally replaces using the old HTML event handler attributes. Further, when properly added, such handlers can also be disconnected if needed using removeEventListener().

### 4. Event Listeners

addEventListener() is the way to register an event listener as specified in W3C DOM. The benefits are as follows:

    It allows adding more than a single handler for an event. This is particularly useful for AJAX libraries, JavaScript modules, or any other kind of code that needs to work well with other libraries/extensions.

    It gives you finer-grained control of the phase when the listener is activated (capturing vs. bubbling).

    It works on any DOM element, not just HTML elements.

- The Event Listener Callback

The event listener can be specified as either a callback function or an object that implements EventListener, whose handleEvent() method serves as the callback function.

The callback function itself has the same parameters and return value as the handleEvent() method; that is, the callback accepts a single parameter: an object based on Event describing the event that has occurred, and it returns nothing.

### 5. Event Bubbling

The process fo capturing an event happens in two stages, capturing and bubbling.

When an event happens on an element, it first runs the handlers on it, then on its parent, then all the way up on other ancestors.

    The process is called “bubbling”, because events “bubble” from the inner element up through parents like a bubble in the water.

**ALMOST** all events bubble

- event.target

A handler on a parent element can always get the details about where it actually happened.

**The most deeply nested element that caused the event is called a target element, accessible as event.target.**

Note the differences from this (=event.currentTarget):

    event.target – is the “target” element that initiated the event, it doesn’t change through the bubbling process.

    this – is the “current” element, the one that has a currently running handler on it.
    For instance, if we have a single handler form.onclick, then it can “catch” all clicks inside the form. No matter where the click happened, it bubbles up to <form> and runs the handler.

In form.onclick handler:

this (=event.currentTarget) is the form element, because the handler runs on it.
event.target is the actual element inside the form that was clicked.

... more on forms next week!

- Stopping Bubbling

A bubbling event goes from the target element straight up. Normally it goes upwards till html, and then to document object, and some events even reach window, calling all handlers on the path.

But any handler may decide that the event has been fully processed and stop the bubbling.

The method for it is event.stopPropagation().

_we often will use e.preventDefault() while dealign with forms ... lets look up what this does and save that page for next week_

- Capturing

There’s another phase of event processing called “capturing”. It is rarely used in real code, but sometimes can be useful.

The standard DOM Events describes 3 phases of event propagation:

Capturing phase – the event goes down to the element.
Target phase – the event reached the target element.
Bubbling phase – the event bubbles up from the element.

_see assets for pic_
